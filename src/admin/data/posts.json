[{"id":"neu-khong-biet-viet-gi-hay-thu-til","title":"Nếu không biết viết gì hãy thử Today I learned","tags":[{"text":"frontend","code":"frontend"}],"published_at":"02/08/2020","content":"Lại __hehe__ là một bài không liên quan gì đến kỹ thuật. Dạo gần đây mình đọc một số bài viết của các người anh đi trước và có trò chuyện với họ. Đồng thời nhiều bạn cũng nói về việc viết blog rằng không biết viết như thế nào và cảm thấy khó khăn về chủ đề cũng như hành văn... Hôm nay mình xin chia sẽ về một cách là __Today I learned__... (til).\r\n\r\nNói đơn giản thì ý nghĩa của nó nằm ngay trong cái câu rồi *\"Hôm nay, tôi đã học...\"*. Điều này bắt đầu từ một thói quen của mình là mình hay ghi chú lại những thứ hay ho mà mình học đã được tiếp thu trong ngày. Ví dụ như một lệnh Linux hoặc một lệnh Git, một CSS trick hay đơn giản là một lỗi tai hại nào đó mà mình vô tình mắc phải. Việc đó giúp mình ghi nhớ tốt hơn cũng nhưng có thể lục lại được nếu một lúc nào đó cần đến. *Thế việc này liên quan gì đến viết blog*? Đúng vậy, lúc trước thì nó không liên quan lắm đến việc viết blog của mình cho đến gần đây mình đọc được một bài viết của anh leader cũ của mình. Ảnh nói sơ về lý do viết blog thì trong đó có đề cập tới việc cũng cố kiến thức cũng như là một cách ghi lại quá trình quá triển của bản thân. Để khi có xin việc hoặc gì đó ngoài cái resume ra thì nhà tuyển dụng có thể nhìn vào cái blog đó mà có cái nhìn rõ hơn về bạn.\r\n\r\nVậy thì __til__ có gì dễ dàng hơn viết blog truyền thống. Theo mình với __til__, bạn sẽ không phải vắt óc suy nghĩ rằng sẽ phải viết chủ đề gì? Chủ đề đó có hay không? Liệu mình đã viết đủ sâu hay chính xác chưa? Hay mệt hơn nửa là viết một hồi rồi lại bí từ, bí cách hành văn rồi lại bỏ. Riêng với __til__ thì bạn sẽ không cần phải vắt óc ra tìm một chủ đề nào đó khi mà mọi thứ đến từ công việc hàng ngày của bạn. Chuyện về văn phong cũng đỡ phải lo khi thường thì nội dung thường khá ngắn gọn và dễ hiểu (vì còn dùng để note mà). Nói cách khác thì đây là một kiểu nhật ký của các lập trình viên. Hãy tưởng tượng một ngày đẹp trời, bạn hoặc team gặp một cái bug kỳ quái nào đó đầy nhức nhói. Sau vài giờ vò đầu, bứt tai thì lời giải cũng xuất hiện. Có thể là một định nghĩa hoặc một kiến thức cơ bản nào đó mà bạn đã bỏ qua. Hay là một lỗi nào phát sinh trong quá trình làm việc cũng nhau và đôi khi ảo diệu hơn nửa là một hành động bạn vẫn xem là vô hại thực tế lại gây ra mối họa khôn lường? Nếu điều đó là bạn thấy hay ho, bạn có thể note vào ngay trong mục __til__ của ngày hôm đó. Rất dễ đúng không? Theo mình thì nếu làm lập trình thì việc gặp các trường hợp như thế sẽ là hết sức thường xuyên nên sẽ không lo lắm việc thiếu nội dung cho blog. Và điều đó cũng giúp chúng ta đỡ... lười hơn khi phải viết một bài dài hàng mớ từ mà đôi khi là viết nửa bài thì chợt nghĩ \"viết dài mà chắc chả ma nào xem, thôi dẹp!\". Ngoài ra mình cũng bổ sung một điểm mạnh nửa là viết blog kiểu này thì cũng khá dễ dàng trong việc tạo một trang blog. Có kha khá cách để tạo một trang __til__ như Wordpress, Github Pages, Vuepress, Jekyll với mỗi ngày sẽ là một bài viết với tiêu đều là ngày tháng năm... Hay lầy lội hơn như mình là mình viết bằng markdown xong chuyển sang HTML rồi ném lên lên Github pages cho lẹ (lâu lâu thấy ẹ quá thì chôm chỉa trên mạng vài đoạn CSS nhìn vào cho bớt ẹ).\r\n\r\nĐể kết thúc bài viết hôm nay thì mình xin chia sẽ một số điều về việc viết blog dạng til. Đầu tiên là không phải vì nội dung ngắn mà chúng ta có thể dễ dãi, nội dung ngắn đồng nghĩa với việc đúng sai rõ ràng. Do thế với những điều bạn viết ra bạn nên tìm hiểu thật rõ ràng cũng như chuẩn xác. Điều này tôi cho chính bạn vì nếu bạn viết một điều mà nó không đúng thì sẽ là điểm trừ nếu nhà tuyển dụng nhìn vào, đáng lo hơn nửa là nói sẽ dẫn tới những bug nguy hiểm nếu bạn tin vào một kiến thức không đúng. Tiếp nửa là là bạn đừng nên quá ngại vì sợ bị đánh giá những điều mình học được, không phải ai cũng biết hết mọi thứ, chỉ có người chịu tiếp thu và người ngừng tiếp thu thôi (chém thế vì thứ gần đây nhất mình note vào đó là lệnh __xargs__ :(( ). Cuối cùng đó là nếu bạn đủ tự tin hoặc muốn rèn luyện, mình khuyên bạn nên viết bằng tiếng Anh vì nội dung khá gãy gọn phù hợp để dùng tiếng Anh và sẵn... PR luôn."},{"id":"dummy-posts","content":"### This is first __dummy post__\r\n\r\nhehe hoho hihi\r\n\r\n*let's try watch this post*\r\n\r\n### hehe\r\n\r\n```php\r\n$a = 1;\r\necho $a;\r\n```","title":"Dummy post e ","tags":[{"text":"frontend","code":"frontend"}]},{"id":"phong-nhan-su-can-toi-xuat-file-excel","content":"Ngày trước mình từng có thời gian làm việc ở hai công ty sản xuất, nơi mà phòng IT chỉ là một bộ phận phụ trợ. Do đó mình có cơ hội được làm việc với các phòng ban khác như nhân sự, kế toán hoặc bán hàng của công ty. Nhờ đó cũng hiểu thêm kha khá các thứ bên ngoài chuyên môn, đặt biệt là làm việc với các file excel.\r\n\r\nỞ các công ty mình làm, phòng IT vì là phòng hỗ trợ nên công việc chính gần như là hiện đại hóa các công việc chân tay, thủ công của các phòng ban bạn. Đương nhiên để làm thủ công thì các phòng ban sẽ thường dùng excel để tính toán và thống kê. Hệ thống ERP cũng bên mình làm cũng bám sát theo việc đó bằng các xuất cho họ các file excel với dữ liệu được tổng hợp sẵn từ các nguồn khác nhau (doanh số, ngày công, giá cả đối tác...) để họ có thể sử dụng cho các công đoạn sau trong luồng làm việc của họ. Trong phần này mình từng gặp phải vấn đề khá đau đầu đó là in dữ liệu liên quan đến ngày công của nhân viên trong tháng ra để nhân sự có thể dựa vào đó để tính lương, thưởng cho nhân viên. Vấn đề mình gặp phải kha khá nhiều đó là công thức tính công phức tạp, cấu trúc cơ sở dữ liệu hiện tại không tốt và các vấn đề khác. Nhưng mình sẽ không đề cập đến các vấn đề đó ở đay mà thay vào đó mình sẽ nói về vấn đề của việc xuất file excel. Đầu tiên là lượng dữ liệu lớn của khoảng gần mười ngàn nhân viên và các thông tin giờ làm, nghỉ phép của họ cộng với một cơ sở dữ liệu không thiết kế phù hợp cho các chức năng đó là cho các công thức tính toán trong các câu truy vấn và xử lý backend (PHP) cực kỳ rườm rà dẫn đến thời gian xuất file cực kỳ chậm. Thứ hai là vì lượng dữ liệu lớn và nhiều cột nên khi xuất ra việc kiểm thử cực kỳ tốn công sức và luôn gây ra cả giác chông chênh khiến nhân sự phải than rằng có hệ thống còn mệt hơn thời làm thủ công. Do mình khá gà thời điểm đó nên toàn làm những cách rất junior và chấp vá, đương nhiên hiệu quả cũng chẳng đâu ra đâu. Sau đó, vì sợ sẽ \"ngu\" thêm nên mình chuyển để một công ty khác với hy vọng được \"đỡ đần\".\r\n\r\nSau cú đỡ đần đó, sau này mình lại trở lại làm việc trong một công ty sản xuất khác. Mình lại gặp vấn đề tương tự như lúc trước. May mắn hơn là lần này mình được tham gia phát triển từ đầu nên cấu trúc dữ liệu tương đối tốt để phát triển nhưng thử thác cũng nhiều hơn khi mà kèm theo việc tính công là... tính lương. Mình vẫn nhớ file dữ liệu mẫu với một mới cột lương 1, lương 2... lương n và đủ các loại thuế khấu trừ. Nhưng cái khó ló cái lầy. Lần này phòng nhân sự hỗ trợ khá tốt cho mình khi mình được nhận một file excel mẫu... có kèm công thức excel và chị nhân sự cũng khá chuyên nghiệp. Sau khi nắm các công thức và mình triển khai như ở công ty cũ, đương nhiên vẫn gặp những vấn đề cũ. Chỉ khác thay vì nhảy vào tối ưu hiệu năng hoặc cố làm sau cho ít bug ở backend thì mình quyết định làm một trò đó là... in ra các công thức excel thay vì là các con số. Đơn giản lúc đó mình nghĩ là thực tế phòng nhân sự hoàn toàn có thể tính được lương bằng excel, thứ họ cần chỉ là những thông tin ngày công, phép, cấp bậc lương... việc của mình chỉ là xuất sẵn những thông tin đó đồng thời in sẵn công thức (mà được họ cho trong file mẫu) để giúp họ đỡ phải tốn công. Nghĩ lầy làm lầy. Mình triển khai luôn và kết quả khá tốt khi mà file xuất ra nhanh hơn vì các câu truy vấn lấy ra dữ liệu cơ bản không nặng lắm và xữ lý backend lúc này cũng chỉ là xuất những công thức excel như __=A1+A2__, thêm nữa gánh nặng khi kiểm tra của phòng nhân sự cũng được giảm bớt vì họ giờ chỉ cần xem sơ qua các công thức xem đặt đúng chưa và các cột cơ bản như lương và ngày công có sai sót không. Những trường hợp cần chỉnh sửa tay thì cũng đỡ hơn khi họ chỉ cần chỉnh vào cột gốc và tự động excel sẽ tính toán lại thay vì phải vào hệ thống hoặc nhờ tới IT.\r\n\r\nĐây không phải là một bài nói về kỹ thuật gì cả mà chỉ là kể một câu chuyện về cách tiếp cận vấn đề và tìm hướng giải quyết. Thời gian làm việc ở các công ty sản xuất có thể nói là không quá thú vị với mình nhưng nó cũng giúp mình có những kỹ năng phụ trợ khá hay ho và đây là một trong số những thứ mình học được trong thời gian này.","title":"Phòng nhân sự cần tôi xuất file excel","tags":[{"text":"frontend","code":"frontend"}]},{"id":"giai-phap-cho-cross-domain-o-frontend","content":"Cũng như các bài dịch trước, sau khi đi làm về, mình lang thang trên [segmentfault](https://segmentfault.com/) tìm xem có gì đó đọc không để đỡ tối cổ. Tình cờ mình tìm được một bài về Vue, nói về vấn đề mình đang gặp công ty. Đọc xong thấy khá hay, nên mình tìm thử xem tác giả còn viết gì không thì ra được bài này. Một bài khá thú vị của tác giả __周绪南 (Châu Tự Nam)__. Một bạn developer còn khá trẻ (bạn sinh năm 1996). Thấy hay và có ích nên mình dịch sang tiếng Việt để chia sẽ cho mọi người. Các bạn có thể vào trang Github của tác giả để tham khảo các source code của bạn ấy nhé.\r\n\r\nLink bài gốc: [前端跨域解决方案](https://segmentfault.com/a/1190000012256432)\r\n\r\n### Browser Same Origin Policy\r\n\r\n#### Browser Same Origin Policy là gì?\r\n\r\nSame Origin Policy là một cơ chế bảo mật của trình duyệt.\r\n\r\nSame Origin Policy có thể giải thích là cách để hạn chế những tài liệu hoặc mã được tải từ một nguồn khác với nguồn của tài nguyên. Đây là một cơ chế quan trọng để chống lại những nguy hại có thể xảy ra do mã độc.\r\n\r\nTrước khi quyết định về việc hai url có cùng một nguồn hay không, hãy xem xét về các thành của một url (Uniform Resource Locator).\r\n\r\nNói về url thì url có các thành phần cơ bản là: __Giao thức__://__Tên domain (hoặc ip)__:__cổng (nếu có chỉ định)__/path\r\n\r\nHãy xem thử ví dụ dưới đây:\r\n\r\nĐối với __http://www.example.com/static__ giao thức chính là http, tên miền là __www.example.com__, path chính là __static__. Số cổng thì bị bỏ qua trong url này vì nó đang dùng cổng mặc định (80).\r\n\r\nĐiều cần chú ý ở đây là phần tên miền. __example.com__ là tên miền chính và __www.example.com__ là tên cấp hai. Và cả với __a.example.com__ (cũng có thể là tên miền cấp hai). Cả ba tên miền trên là ba tên miền khác nhau.\r\n\r\nTôi sẽ không đi sâu vào chi tiết ở đây. Để biết thêm thông tin, bạn có thể tìm hiểu thêm các tài liệu về mạng máy tính.\r\n\r\nTrở lại với câu hỏi cũ. Liệu có cách nào để nhận biết các trang có cùng tên miền không?\r\n\r\nCâu trả lời là nếu giao thức và cổng (nếu được chỉ định) và hai tên miền đều giống nhau thì cả hai trang được xem là cùng một nguồn.\r\n\r\nHãy nói dễ hiểu hơn là ba yếu tố để xác định sự tương đồng chính là: giao thức, tên miền và cổng.\r\n\r\nCần lưu ý là nếu tên miền đó là tên miền cấp hai chẳng hạn như __www.example.com__ được đề cập ở trên, đồng thời tên miền đó được liên kết với một tên miền cấp hai khác là __a.example.com__. Mặc dù có tên miền chính giống nhau, nhưng tên miền phụ khác nhau nên chúng không phải cùng tên miền. Do đó, kéo theo hai tên miền này không thể tính là tương đồng. Điều này cũng tương tự với tên miền cấp ba, v.v...\r\n\r\nBảng dưới đây cung cấp những ví dụ về việc đánh giá độ tương đồng của các url với __http://store.company.com/dir/page.html__\r\n\r\n|__url__|__Kết quả__|__Lý do__|\r\n|---|:---:|---|\r\n|http://store.company.com/dir2/other.html|Tương đồng||\r\n|http://store.company.com/dir/inner/another.html|Tương đồng||\r\n|https://store.company.com/secure|Không tương đồng|Khác giao thức (http và https)|\r\n|http://store.company.com:81/dir/etc.html|Không tương đồng|Khác cổng (80 và 81)|\r\n|http://news.company.com/dir/other.html|Không tương đồng|Khác tên miền (news và store)|\r\n\r\n#### Giới thiệu về Cookie và Session\r\nKhi bàn về Same Origin Policy, có một số điều cần thiết phải làm. Đó là nói về Cookie\r\n\r\nKhi nói về Cookie, chúng ta nên tìm hiểu thêm về Session\r\n\r\nĐối với cả hai, đây không cần phải có một phần giới thiệu lớn.\r\n\r\nNên ở đây, chúng ta tóm tắt ngắn gọn nhau sau:\r\n\r\n- Cookie bị hạn chế bởi same-origin policy. Cookie ở trang A không thể được truy cập và chỉnh sửa khi bạn đang ở trang B.\r\n- Sức lưu trữ tối đa của Cookie thường phổ biến ở mức 4KB và được thiết lập bởi server. Có thể chỉ định nội dung và vòng đời của Cookie được tạo ra bằng cách thiết lập giá trị cho Set-Cookie trong HTTP headers. Nếu được tạo ra bởi trình duyệt, nó sẽ bị vô hiệu hóa sau khi trình duyệt đóng lại.\r\n- Cookie được lưu trữ ở trình duyệt, bởi vì mỗi lần một HTTP request được gửi, Cookie được gắn vào HTTP header một cách mặc định. Do điều đó nên Cookie chủ yếu được sử dụng nhầm xác thực thông tin. Đồng thời Cookie cũng không thường dùng để lưu trữ thông tin vì như vậy sẽ làm Cookie bị phình ra.\r\n- Session được lưu trữ trên server và thường được kết hợp sử dụng với Cookie nhằm thực hiện xác thực và duy trì trạng thái.\r\n\r\nMột số ví dụ về Cookie và Session\r\n\r\nGiả sử chúng ta có một hệ thống quản lý thông tin sinh viên. Tại một thời điểm mà cơ sở dữ liệu đã có đủ các thông tin liên quan đến sinh viên như tài khoản, mật khẩu, các thông tin cá nhân... Sau đó, sinh viên đăng nhập vào hệ thống bằng các gửi thông tin tài khoản qua mật khẩu tới server backend bằng phương thức POST. Khi đó server sẽ thực hiện kiểm tra các tham số gửi lên và kiểm tra xem nó có khớp với những gì được lưu trong cơ sở dữ liệu.\r\n\r\nNếu quá trình kiểm tra thành công, tức là thông tin gửi lên là chính xác. Server backend sẽ ghi lại giá trị trong Session. Thường là tên tài khoản hoặc một trường duy nhất nào có của người dùng (id chẳng hạn).\r\n\r\nSau khi lưu dữ liệu lại trong Session, server sẽ phản hồi về cho phía client rằng quá trình đăng nhập đã thành công và client có thể thực hiện các chức năng (đòi hỏi phải đăng nhập) tiếp theo. Đồng thời, cũng trong thời điểm này server backend sẽ thêm một thuộc tính là Set-Cookie trong HTTP response, giá trị của nó chính là SessionID của Session hiện tại (SessionID này đang trỏ đến Session hiện tại của chúng ta, trong Express thì express-session sẽ thực hiện thiết lập quá trình này). Tất nhiên quá trình này cũng bao gồm việc thiết lập một số thuộc tính khác của Cookie như Expire time...\r\n\r\nKhi trình duyệt nhận được HTTP response, nó sẽ thiết lập một cookie local. Thời gian hết hạn chính được xác định bởi giá trị của trường Expires trong Set-Cookie thuộc response trả về. Nếu trình duyệt bị đóng (hoặc khi Session hết hạn) mọi thứ sẽ bị vô hiệu hóa.\r\n\r\nSau quá trình đăng nhập, mỗi request gửi đến server từ trình duyệt sẽ được thêm những thông tin vài cookie một cách mặc định. Theo cách thức này, mỗi khi nhận được request từ client thì server sẽ tìm kiếm Session của chúng ta dựa vào SessionID trong cookie.\r\n\r\nNếu SessionID gửi lên được tìm thấy thì có nghĩa là client đã đăng nhập và chúng ta có thể thực hiện các chức năng tiếp theo.\r\n\r\nCó một điều đáng lưu ý là cơ chế xác minh Session này người dùng hiện tại chỉ có thể lấy được Session của họ và sẽ không thể lấy được những Session khác. Mỗi Session của mỗi người dùng cũng giữ sự độc lập với nhau. Đồng nghĩa với việc khi có nhiều người dùng hệ thống trong một thời gian thì hệ thống cũng sẽ lưu trữ nhiều Session tương ứng.\r\n\r\nTrên đây, tôi đã trình bày về các ví dụ của Session và Cookie.\r\n\r\n#### Giới thiệu về iframe\r\nKhi nói về các hạn chế của Same Origin Policy thì chúng ta còn có thể đề cập đến iframe.\r\n\r\niframe dùng để nhúng một trang con trong một trang lớn. Trong quá trình phát triển sản phẩm hằng ngày chúng ta không thể tránh được những vấn đề khi giao tiếp giữa các iframe khác nhau trong trang. Như sử dụng DOM, function hoặc biến của các iframe khác.\r\n\r\niframe cũng chịu ảnh hưởng bởi Same Origin Policy. Thuộc tính src của iframe chính là url trong Same Origin Policy. Còn về việc tương tác với DOM, biến và function của iframe cũng không quá phức tạp, chúng ta có thể dùng __contentDocument__ và __contentWindow__\r\n\r\nNếu hai iframe không tương đồng thì khả năng truy cập sẽ bị giới hạn.\r\n\r\nĐể giải quyết vấn đề trên. HTML5 giới thiệu một API mới đó là __postMessage__, một phương thức chủ yếu để giải quyết vấn đề liên lạc giữa iframe và cross-domain.\r\n\r\nSau đâu là một ví dụ: Nếu có hai trang khác nhau. Url của trang A là *http://localhost:4002/parent.html* còn url của trang B là http://localhost:4003/child.html. Bây giờ, tôi sẽ nhúng trang B vào trang A dưới dạng iframe cùng với đoạn code được đặt như bên dưới... Bây giờ tôi muốn gửi một thông điệp vào trang con B.\r\n\r\nCode ở trang A\r\n\r\n```html\r\n<body>\r\n<h1>A页面</h1>\r\n<iframe src=\"http://localhost:4003/child.html\" id=\"child\">\r\n</iframe>\r\n<script>\r\n    window.onload = function() {\r\n        document.getElementById(\"child\").contentWindow.postMessage(\"父页面发来贺电\", \"http://localhost:4003\");\r\n    } // 父页面发来贺电 => lời nhắn từ trang gốc\r\n</script>\r\n</body>\r\n```","title":"[Dịch] Những giải pháp cho vấn đề cross-domain của frontend","tags":[{"text":"frontend","code":"frontend"}]}]