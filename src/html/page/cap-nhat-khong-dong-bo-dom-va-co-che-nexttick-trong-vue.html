<!-- build:title -->[Dịch] Vấn đề cập nhật DOM không đồng bộ và cơ chế nextTick trong Vue<!-- /build:title -->

<!-- build:meta -->
<meta name="description" content="Định nghĩa deep copy trong Javascript và các phương pháp thực hiện">
<meta name="keywords" content="javascript,deepcopy,copy,tasynguyen3894,js">
<meta name="author" content="Tasy Nguyen">
<!-- /build:meta -->

<!-- build:menu --><div class="navbar-fixed home-bg"><!-- /build:menu -->

<!-- build:quotes -->
<div class="navbar-quotes-content">
Raised up by Xiao He, cast down by Xiao He.
</div>
<div class="navbar-quotes-speaker">
</div>
<!-- /build:quotes -->

<!-- build:body -->
<h1>[Dịch] Vấn đề cập nhật DOM không đồng bộ và cơ chế nextTick trong Vue</h1>
<div class="home-content">
<div class="blog-detail">
<div class="blog-detail-date">Đăng lúc 29/10/2018</div>
<div class="tags">
    <span><a href="tags.html?tag=javascript">javascript</a></span>
    <span><a href="tags.html?tag=translate">translate</a></span>
</div>
<!-- https://segmentfault.com/a/1190000013314893 -->
<p>Nội dung bài viết này chủ yếu nói về quá trình cập nhật bất đồng bộ của DOM  và cơ chế <b>nextTick</b> trong <b>Vue</b>. Do đó, đòi hỏi bạn đọc cần có một tí kinh nghiệm về Vue và event loop của Javascript.</p>
<p>Giới thiệu: Cập nhật bất đồng bộ của DOM</p>
<pre><code class="html">
&lt;template&gt;
    &lt;div&gt;
        &lt;div ref="test"&gt;{{test}}&lt;/div&gt;
        &lt;button @click="handleClick"&gt;tet&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

</code></pre>

<pre><code class="javascript">
export default {
    data () {
        return {
            test: 'begin'
        };
    },
    methods () {
        handleClick () {
            this.test = 'end';
            console.log(this.$refs.test.innerText); // xuất ra "begin"
        }
    }
}

</code></pre>
<p>Kết quả khi in ra lại là <i>begin</i> thay vì <i>end</i> như chúng ta đã set. Điều này cho thấy, đã có sự không đồng bộ trong quá trình cập nhật DOM</p>
<p>Điều này cũng đã được giải thích trong tài liệu chính thức của <b>Vue</b></p>
<div class="blog-detail-quote">
    Có thể bạn không nhận ra, <b>Vue</b> thực hiện cập nhật DOM một cách không đồng bộ. Bất cứ sự thay đổi nào của các dữ liệu được quan sát. Khi đó <b>Vue</b> sẽ tạo ra một hàng đợi và đặt những thay đổi đó vào trong một event loop. Nếu một <b>watcher</b> được trigger nhiều lần thì nó cũng sẽ chỉ đẩy vào hàng đợi một lần thôi. Việc loại bỏ các hành động trùng lặp này rất quan trọng, vì nó tránh việc phải thực hiện các tính toán không cần thiết cùng các thao tác thừa thải ở DOM. Sau đó, trong event loop <i>"tick"</i> tiếp theo, <b>Vue</b> sẽ làm mới hàng đợi và thực hiện các công việc thực tế (đã bị loại bỏ).
</div>
<p>Tóm lại, tất cả những thay đổi dữ liệu được diễn ra trong một vòng lặp sự kiện hiện tại sẽ được kích hoạt trong sự kiện <b>tick</b> của vòng lặp tiếp theo, đây cũng được xem là một "batch". (Lưu ý rằng 
    <!-- Dịch sau khi đọc code -->
    )</p>
<h4>Watcher queue</h4>
<p>Quan sát source code của <b>Watcher</b>, chúng ta có thể tìm ra một điều rằng  hoạt động cập nhật của <b>watcher</b> cũng không thật sự đồng bộ (Lưu ý: thuộc tính <b>sync</b> mặc định là <i>false</i>, nghĩa là không đồng bộ)</p>
<pre><code class="javascript">
update () {
    /* istanbul ignore else */
    if (this.lazy) {
        this.dirty = true
    } else if (this.sync) {
        /* Nếu đồng bộ thì sẽ chạy thẳng hàm run để render lại view */
        this.run()
    } else {
        /* Nếu xữ lý không đồng bộ thì sẽ cho vào hàng đợi. Tick tiếp theo sẽ thực thi nó */
        queueWatcher(this)
    }
}

</code></pre>
<p>Code của <b>queueWatcher(this)</b> như sau:</p>
<pre><code class="javascript">
// Đưa observer object vào hàng đợi. Nếu đã tồn tại trong hàng đợi, đối tượng sẽ bị bỏ qua. Trừ khi hàng đợi được làm mới.
export function queueWatcher (watcher: Watcher) {
    /* Lấy id của watcher */
    const id = watcher.id
    /* Kiểm tra lại xem id có tồn tại hay chưa. Nếu có sẽ bị bỏ qua. Set giá trị vào has nếu nó tồn tại. Để lần tiếp theo có thể kiểm tra. */
    if (has[id] == null) {
        has[id] = true
        if (!flushing) {
            /* Nếu không có flush, watcher sẽ được push vào hàng đợi. */
            queue.push(watcher)
        } else {
        ...
        }
        // queue the flush
        if (!waiting) {
            waiting = true
            nextTick(flushSchedulerQueue)
        }
    }
}
        
</code></pre>
<p>Có vài điều cần lưu ý ở đoạn code này:</p>
<ul>
    <li>Điều đầu tiên bạn cần biết là khi <b>watcher</b> thực hiện <b>update</b> mặc định sẽ không đồng bộ. Nó sẽ thực hiện hai điều sau đây:
        <ul>
            <li>Xác định xem <i>id</i> của <b>watcher</b> có nằm trong <b>has</b> hay không.</li>
            <li>Nếu có, bạn sẽ không cần thêm <b>watcher</b> vào hàng đợi. Nếu không thì không cần làm gì cả.</li>
        </ul>
    </li>
    <li>Bên trong <b>nextTick(flushSchedulerQueue)</b>, hàm <b>flushScheduleQueue</b> có chức năng cập nhật lại <i>view</i>. Nó sẽ lấy tất cả các <b>watcher</b> trong <b>queue</b> để thực hiện cập nhật view tương ứng.</li>
    <li>Cốt lõi thật ra nằm ở hàm <b>nextTick</b>. Vì vậy chúng ta hãy xem thử về hàm <b>nextTick</b></li>
</ul>
<h4>nextTick</h4>
<p>Hàm <b>nextTick</b> thực hiện hai việc sau. Một là tạo ra một <b>timerFunc</b>, tham gia vào callback dưới dạng <b>microTask</b> hoặc <b>marcoTask</b> bên trong một event loop. Hai là đặt những callback đó vào một callback queue, đồng thời chờ đến thời điểm thích hợp để thực thi.</p>
<p></p>
<pre><code class="javascript">
if (typeof Promise !== 'undefined' && isNative(Promise)) {
    /*使用Promise*/
    var p = Promise.resolve()
    var logError = err => { console.error(err) }
    timerFunc = () => {
        p.then(nextTickHandler).catch(logError)
        // in problematic UIWebViews, Promise.then doesn't completely break, but
        // it can get stuck in a weird state where callbacks are pushed into the
        // microTask queue but the queue isn't being flushed, until the browser
        // needs to do some other work, e.g. handle a timer. Therefore we can
        // "force" the microTask queue to be flushed by adding an empty timer.
        if (isIOS) setTimeout(noop)
    }
} else if (typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
    )) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    /*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/
    var counter = 1
    var observer = new MutationObserver(nextTickHandler)
    var textNode = document.createTextNode(String(counter))
    observer.observe(textNode, {
        characterData: true
    })
    timerFunc = () => {
        counter = (counter + 1) % 2
        textNode.data = String(counter)
    }
} else {
    // fallback to setTimeout
    /* istanbul ignore next */
    /*使用setTimeout将回调推入任务队列尾部*/
    timerFunc = () => {
        setTimeout(nextTickHandler, 0)
    }
}
        
</code></pre>
<p>Cần lưu ý rằng các callback sẽ được gọi theo thứ tự ưu tiên như sau <b>Promise</b>, <b>MutationObserver</b> và <b>setTimeout</b>. Vơi hai trường hợp đầu tiên thì sẽ tạo ra <b>microTask</b>, còn trường hợp còn lại sẽ tạo ra <b>marcoTask</b></p>
<!-- Tối nghĩa, cần dịch lại sau khi hiểu code -->
<p>Lý do của việc phân chia độ ưu tiên để xem xét sự tương thích của các trình duyệt (IE thì có hỗ trợ sẵn Promise). Bên cạnh đó, <b>Promise</b> có độ ưu tiên cao nhất là vì <i>Promise.resolve().then</i> thuộc về một <b>microTask</b>. Sau khi trình duyệt thi hành <b>marcoTask</b> trong một <b>Tick</b>, nó sẽ xóa toàn bộ các <b>microTask</b> trong <b>Tick</b>, đồng thời render lại UI. Quá trình cập nhật DOM được hoàn thành trong lúc <b>Tick</b> đang thực hiện <b>microTask</b>. UI render sẽ ít hơn một lần nếu sử dụng <b>marcoTask</b> được tạo ra bởi <b>setTimeout</b>.</p>
<!-- Thiếu -->
<p>Chức năng của <b>nextTickHandler</b></p> 
<pre><code class="javascript">
function nextTickHandler () {
    pending = false
    /* Thực hiện tất cả callback */
    const copies = callbacks.slice(0)
    callbacks.length = 0
    for (let i = 0; i < copies.length; i++) {
        copies[i]()
    }
}
</code></pre>
<p>Biến <i>callbacks</i> được sử dụng bởi hàm <b>nextTickHandler</b>. Và nhưng tôi đã nói ở trên về chức năng thứ hai của <b>nextTick</b> đó là "chờ đợi thời điểm thích hợp để triển khai" đó là bởi vì thời điểm thực hiện của <b>timerFunc</b> là khác nhau. Nếu là <b>Promise</b>/<b>MutationObserver</b> callback của <b>nextTickHandler</b> sẽ là một <b>microTask</b>, nó sẽ được kết thúc ở cuối <b>Tick</b> hiện tại. Nếu là <b>setTimeout</b> thì callback của <b>nextTickHandler</b> sẽ là một <b>marcoTask</b>, nó sẽ được thực hiện trong <b>Tick</b> tiếp theo.</p>
<p></p>




<div class="blog-detail-comments">
    <!-- <div id="show-comment-box">
        Comment
    </div> -->
    <div id="post-comment" >
        <div id="disqus_thread"></div>
        <script>
        /**
        *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
        *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
        /*
        var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
        */
        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://https-tasynguyen3894-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
</div>
<div class="blog-break-line"></div>
</div>
</div>
<!-- /build:body -->