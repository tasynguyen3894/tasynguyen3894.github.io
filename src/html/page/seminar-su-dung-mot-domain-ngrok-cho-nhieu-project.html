<!-- build:title -->Seminar: Sử dụng một domain ngrok cho nhiều project<!-- /build:title -->

<!-- build:menu --><div class="navbar-fixed home-bg"><!-- /build:menu -->

<!-- build:quotes -->
<div class="navbar-quotes-content">
	The programmers of tomorrow are the wizards of the future.
</div>
<div class="navbar-quotes-speaker">
	Gabe Newell
</div>
<!-- /build:quotes -->

<!-- build:body -->
<h1>Seminar: Sử dụng một domain ngrok cho nhiều project</h1>
<div class="home-content">
	<div class="blog-detail">
		<div class="blog-detail-date">Đăng lúc 03/08/2018</div>
		<div class="tags">
            <span><a href="tags.html?tag=laravel">laravel</a></span>
            <span><a href="tags.html?tag=nginx">nginx</a></span>
            <span><a href="tags.html?tag=seminar">seminar</a></span>
		</div>
        <h4>Mở đầu</h4>
        <p>Hiện tại, vì hệ thống sử dụng micro service nên sẽ có nhiều hệ thống nhỏ được chia tách. Đi kèm mỗi hệ thống chính là domain khác nhau. Các hệ thống sẽ làm việc với nhau chủ yếu qua API. Đôi lúc việc này sẽ gây ảnh hưởng đến quá trình làm việc. Có thể thấy trong các ví dụ sau:</p>
        <ul>
            <li>Chúng ta cần làm một chức năng liên quan đến webhook và app. App thì cần https để đăng nhập và làm một số việc khác. Webhook cũng cần một địa chỉ ngrok để nhận request từ shopify.</li>
            <li>Sự khác nhau của port docker và port máy tính. Có thể lấy ví dụ như có một port của ES ở docker là 83 và ở ngoài là 8003. Lúc này sẽ khá bối rối khi chúng ta chỉ có một key trong .env để định nghĩa cho domain của ES.</li>
        </ul>
        <p>Thật sự những vấn đề trên đều có thể giải quyết được với một ngrok như hiện tại. Ở trường hợp đầu là chúng ta có thể chuyển đổi ngrok cho webhook hoặc app khi nào cần kiểm tra các chức năng trên chúng. Với trường hợp port thì cũng có nhiều cách như tạo ra hai key trong .env kiểu như ES_FRONTEND_DOMAIN và ES_BACKEND_DOMAIN. Hay đơn giản hơn là cho 2 port trùng nhau là xong.</p>
        <p>Nhưng có cũng tốt, vì vậy bài viết này được ra đời. Cách thức thực hiện thì cũng khá dễ làm. Đơn giản chỉ là sử dụng proxy pass. Có thể dùng Apache hoặc Nginx tùy vào điều kiện của dự án.</p>
        <h4>Triển khai proxy pass</h4>
        <p>Vì nhiều anh em sử dụng Laradock kèm theo nginx nên mình sẽ nói về việc triển khai proxy_pass với nginx trước.</p>
        <p></p>
        <!-- <div class="blog-detail-comments">
			<div id="disqus_thread"></div>
			<script>
			/**
			*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');
			s.src = 'https://https-tasynguyen3894-github-io.disqus.com/embed.js';
			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
		</div> -->
	</div>
</div>
<!-- /build:body -->