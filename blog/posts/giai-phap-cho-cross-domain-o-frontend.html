<!DOCTYPE html>
<html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>[Dịch] Những giải pháp cho vấn đề cross-domain của frontend | Sang Nguyen | Blog</title>
        <meta name="description" content="[Dịch] Những giải pháp cho vấn đề cross-domain của frontend">
<meta name="keywords" content="Javascipt, jQuery, html, css, my stories">
<meta name="author" content="Tasy Nguyen">
        <link rel="shortcut icon" type="image/png" href="/public/img/css/tasynguyen.png"/>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
        <link rel="stylesheet" href="/assets/css/blog_style.css">
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/styles/default.min.css">
        <link rel="alternate" type="application/rss+xml" title="Tasy Nguyen Blog" href="rss.xml">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    </head>
    <body>
        <div class="navbar-fixed home-bg">            <div class="navbar-content">
                <!-- <div class="navbar-button">
                    <span id="nav-info-toggle">
                        <span class="fa fa-code" ></span> 
                        <span class="toggle-content">Tasy Nguyen</span>
                    </span>
                </div>
                <div class="navbar-button-close" id="nav-info-mobile-close">
                    <span class="fa fa-arrow-left"></span>
                </div> -->
                <div class="navbar-short-info" id="nav-info">
                    <div class="navbar-short-info-avatar">
                        <img src="https://avatars3.githubusercontent.com/u/18634365?s=400&v=4" alt="">
                    </div>
                    <h3>Nguyen Thai Sang</h3>
                    <h4>Web developer</h4>
                    <p>Hello world!</p>
                    <div class="navbar-shor-info-contact">
                        <a class="twitter" target="_blank" href="https://twitter.com/tasyit"><span class="fa fa-twitter"></span></a>
                        <a class="linkedin" target="_blank" href="https://linkedin.com/in/thaisangnguyen3894/"><span class="fa fa-linkedin"></span></a>
                        <a class="github" target="_blank" href="https://github.com/tasynguyen3894/"><span class="fa fa-github"></span></a>
                    </div>
                </div>
                <div class="navbar-quotes" id="navbar-quotes">
                    <div class="navbar-quotes-content">
    Sweat saves blood, blood saves lives, but brains saves both.
</div>
<div class="navbar-quotes-speaker">
    Erwin Rommel
</div>
                </div>
            </div>
        </div>
        <div class="container">
            <div class="container-content">
                <!-- <div class="navbar-button">
                    <span class="fa fa-arrow-right" id="nav-info-mobile-open"></span>

                </div> -->
                <div class="navbar-menu">
                    <div class="title-mobile">
                        <a href="index.html">Tasy Nguyen Blog</a>
                        <span id="toggle-button-mb" class="fa fa-bars"></span>
                    </div>
                    <ul id="menu-mobile">
                        <li><a href="/blog">Blog</a></li>
                        <li><a href="/">Sangnguyen.dev</a></li>
                    </ul>
                </div>
                <div class="main-content">
                    <h1>[Dịch] Những giải pháp cho vấn đề cross-domain của frontend</h1>
<div class="home-content">
<div class="blog-detail">
<div class="blog-detail-date">Đăng lúc 09/08/2018</div>
<div class="tags">
    <span><a href="tags.html?tag=my-stories">my stories</a></span>
</div>

<p>Cũng như các bài dịch trước, sau khi đi làm về, mình lang thang trên <a href="https://segmentfault.com" target="_blank">segmentfault</a> tìm xem có gì đó đọc không để đỡ tối cổ. Tình cờ mình tìm được một bài về Vue, nói về vấn đề mình đang gặp công ty. Đọc xong thấy khá hay, nên mình tìm thử xem tác giả còn viết gì không thì ra được bài này. Một bài khá thú vị của tác giả <b>周绪南</b> (Châu Tự Nam). Một bạn developer còn khá trẻ (bạn sinh năm 1996). Thấy hay và có ích nên mình dịch sang tiếng Việt để chia sẽ cho mọi người. Các bạn có thể vào trang <a href="https://github.com/stevennzhou" target="_blank">Github</a> của tác giả để tham khảo các source code của bạn ấy nhé.</p>
<p>Link bài gốc: <a href="https://segmentfault.com/a/1190000012256432" target="_blank">前端跨域解决方案</a></p>
<h4>Browser Same Origin Policy</h4>
<div class="blog-break-line"></div>
<h4>Browser Same Origin Policy là gì?</h4>
<p>Same Origin Policy là một cơ chế bảo mật của trình duyệt.</p>
<p>Same Origin Policy có thể giải thích là cách để hạn chế những tài liệu hoặc mã được tải từ một nguồn khác với nguồn của tài nguyên. Đây là một cơ chế quan trọng để chống lại những nguy hại có thể xảy ra do mã độc.</p>
<p>Trước khi quyết định về việc hai url có cùng một nguồn hay không, hãy xem xét về các thành của một url (Uniform Resource Locator).</p>
<p>Nói về url thì url có các thành phần cơ bản là: <b>Giao thức</b>://<b>Tên domain (hoặc ip)</b>:<b>cổng (nếu có chỉ định)</b>/path</p>
<p>Hãy xem thử ví dụ dưới đây:</p>
<p>Đối với <b>http://www.example.com/static</b> giao thức chính là <b>http</b>, tên miền là <b>www.example.com</b>, path chính là <b>static</b>. Số cổng thì bị bỏ qua trong url này vì nó đang dùng cổng mặc định (80).</p>
<p>Điều cần chú ý ở đây là phần tên miền. <b>example.com</b> là tên miền chính và <b>www.example.com</b> là tên cấp hai. Và cả với <b>a.example.com</b> (cũng có thể là tên miền cấp hai). Cả ba tên miền trên là ba tên miền khác nhau.</p>
<p>Tôi sẽ không đi sâu vào chi tiết ở đây. Để biết thêm thông tin, bạn có thể tìm hiểu thêm các tài liệu về mạng máy tính.</p>
<p>Trở lại với câu hỏi cũ. Liệu có cách nào để nhận biết các trang có cùng tên miền không?</p>
<p>Câu trả lời là nếu giao thức và cổng (nếu được chỉ định) và hai tên miền đều giống nhau thì cả hai trang được xem là cùng một nguồn.</p>
<p>Hãy nói dễ hiểu hơn là ba yếu tố để xác định sự tương đồng chính là: giao thức, tên miền và cổng.</p>
<p>Cần lưu ý là nếu tên miền đó là tên miền cấp hai chẳng hạn như <b>www.example.com</b> được đề cập ở trên, đồng thời tên miền đó được liên kết với một tên miền cấp hai khác là <b>a.example.com</b>. Mặc dù có tên miền chính giống nhau, nhưng tên miền phụ khác nhau nên chúng không phải cùng tên miền. Do đó, kéo theo hai tên miền này không thể tính là tương đồng. Điều này cũng tương tự với tên miền cấp ba, v.v...</p>
<p>Bảng dưới đây cung cấp những ví dụ về việc đánh giá độ tương đồng của các url với <b>http://store.company.com/dir/page.html</b></p>
<div class="overflow-scroll">
    <table>
        <thead>
            <th>url</th>
            <th>Kết quả</th>
            <th>Lý do</th>
        </thead>
        <tbody>
            <tr>
                <td>http://store.company.com/dir2/other.html</td>
                <td>Tương đồng</td>
                <td></td>
            </tr>
            <tr>
                <td>http://store.company.com/dir/inner/another.html</td>
                <td>Tương đồng</td>
                <td></td>
            </tr>
            <tr>
                <td>https://store.company.com/secure</td>
                <td>Không tương đồng</td>
                <td>Khác giao thức (http và https)</td>
            </tr>
            <tr>
                <td>http://store.company.com:81/dir/etc.html</td>
                <td>Không tương đồng</td>
                <td>Khác cổng (80 và 81)</td>
            </tr>
            <tr>
                <td>http://news.company.com/dir/other.html</td>
                <td>Không tương đồng</td>
                <td>Khác tên miền (news và store)</td>
            </tr>
        </tbody>
    </table>
</div>
<h4>Giới thiệu về Cookie và Session</h4>
<p>Khi bàn về Same Origin Policy, có một số điều cần thiết phải làm. Đó là nói về Cookie</p>
<p>Khi nói về Cookie, chúng ta nên tìm hiểu thêm về Session</p>
<p>Đối với cả hai, đây không cần phải có một phần giới thiệu lớn.</p>
<p>Nên ở đây, chúng ta tóm tắt ngắn gọn nhau sau:</p>
<ul>
    <li>Cookie bị hạn chế bởi same-origin policy. Cookie ở trang A không thể được truy cập và chỉnh sửa khi bạn đang ở trang B.</li>
    <li>Sức lưu trữ tối đa của Cookie thường phổ biến ở mức 4KB và được thiết lập bởi server. Có thể chỉ định nội dung và vòng đời của Cookie được tạo ra bằng cách thiết lập giá trị cho Set-Cookie trong HTTP headers. Nếu được tạo ra bởi trình duyệt, nó sẽ bị vô hiệu hóa sau khi trình duyệt đóng lại.</li>
    <li>Cookie được lưu trữ ở trình duyệt, bởi vì mỗi lần một HTTP request được gửi, Cookie được gắn vào HTTP header một cách mặc định. Do điều đó nên Cookie chủ yếu được sử dụng nhầm xác thực thông tin. Đồng thời Cookie cũng không thường dùng để lưu trữ thông tin vì như vậy sẽ làm Cookie bị phình ra.</li>
    <li>Session được lưu trữ trên server và thường được kết hợp sử dụng với Cookie nhằm thực hiện xác thực và duy trì trạng thái.</li>
</ul>
<p>Một số ví dụ về Cookie và Session</p>
<p>Giả sử chúng ta có một hệ thống quản lý thông tin sinh viên. Tại một thời điểm mà cơ sở dữ liệu đã có đủ các thông tin liên quan đến sinh viên như tài khoản, mật khẩu, các thông tin cá nhân... Sau đó, sinh viên đăng nhập vào hệ thống bằng các gửi thông tin tài khoản qua mật khẩu tới server backend bằng phương thức POST. Khi đó server sẽ thực hiện kiểm tra các tham số gửi lên và kiểm tra xem nó có khớp với những gì được lưu trong cơ sở dữ liệu.</p>
<p>Nếu quá trình kiểm tra thành công, tức là thông tin gửi lên là chính xác. Server backend sẽ ghi lại giá trị trong Session. Thường là tên tài khoản hoặc một trường duy nhất nào có của người dùng (id chẳng hạn).</p>
<p>Sau khi lưu dữ liệu lại trong Session, server sẽ phản hồi về cho phía client rằng quá trình đăng nhập đã thành công và client có thể thực hiện các chức năng (đòi hỏi phải đăng nhập) tiếp theo. Đồng thời, cũng trong thời điểm này server backend sẽ thêm một thuộc tính là Set-Cookie trong HTTP response, giá trị của nó chính là SessionID của Session hiện tại (SessionID này đang trỏ đến Session hiện tại của chúng ta, trong Express thì express-session sẽ thực hiện thiết lập quá trình này). Tất nhiên quá trình này cũng bao gồm việc thiết lập một số thuộc tính khác của Cookie như Expire time...</p>
<p>Khi trình duyệt nhận được HTTP response, nó sẽ thiết lập một cookie local. Thời gian hết hạn chính được xác định bởi giá trị của trường Expires trong Set-Cookie thuộc response trả về. Nếu trình duyệt bị đóng (hoặc khi Session hết hạn) mọi thứ sẽ bị vô hiệu hóa.</p>
<!--?-->
<p>Sau quá trình đăng nhập, mỗi request gửi đến server từ trình duyệt sẽ được thêm những thông tin vài cookie một cách mặc định. Theo cách thức này, mỗi khi nhận được request từ client thì server sẽ tìm kiếm Session của chúng ta dựa vào SessionID trong cookie.</p>
<p>Nếu SessionID gửi lên được tìm thấy thì có nghĩa là client đã đăng nhập và chúng ta có thể thực hiện các chức năng tiếp theo.</p>
<p>Có một điều đáng lưu ý là cơ chế xác minh Session này người dùng hiện tại chỉ có thể lấy được Session của họ và sẽ không thể lấy được những Session khác. Mỗi Session của mỗi người dùng cũng giữ sự độc lập với nhau. Đồng nghĩa với việc khi có nhiều người dùng hệ thống trong một thời gian thì hệ thống cũng sẽ lưu trữ nhiều Session tương ứng.</p>
<p>Trên đây, tôi đã trình bày về các ví dụ của Session và Cookie.</p>
<h4>Giới thiệu về iframe</h4>
<p>Khi nói về các hạn chế của Same Origin Policy thì chúng ta còn có thể đề cập đến iframe.</p>
<p>iframe dùng để nhúng một trang con trong một trang lớn. Trong quá trình phát triển sản phẩm hằng ngày chúng ta không thể tránh được những vấn đề khi giao tiếp giữa các iframe khác nhau trong trang. Như sử dụng DOM, function hoặc biến của các iframe khác.</p>
<p>iframe cũng chịu ảnh hưởng bởi Same Origin Policy. Thuộc tính src của iframe chính là url trong Same Origin Policy. Còn về việc tương tác với DOM, biến và function của iframe cũng không quá phức tạp, chúng ta có thể dùng <b>contentDocument</b> và <b>contentWindow</b></p>
<p>Nếu hai iframe không tương đồng thì khả năng truy cập sẽ bị giới hạn.</p>
<p>Để giải quyết vấn đề trên. HTML5 giới thiệu một API mới đó là <b>postMessage</b>, một phương thức chủ yếu để giải quyết vấn đề liên lạc giữa iframe và cross-domain.</p>
<p>Sau đâu là một ví dụ: Nếu có hai trang khác nhau. Url của trang A là <i>http://localhost:4002/parent.html</i> còn url của trang B là <i>http://localhost:4003/child.html</i>. Bây giờ, tôi sẽ nhúng trang B vào trang A dưới dạng iframe cùng với đoạn code được đặt như bên dưới... Bây giờ tôi muốn gửi một thông điệp vào trang con B.</p>
<p>Code ở trang A</p>
<pre><code class="html">
&lt;body&gt;
&lt;h1&gt;A页面&lt;/h1&gt;
&lt;iframe src="http://localhost:4003/child.html" id="child"&gt;
&lt;/iframe&gt;
&lt;script&gt;
    window.onload = function() {
        document.getElementById("child").contentWindow.postMessage("父页面发来贺电", "http://localhost:4003");
    } // 父页面发来贺电 => lời nhắn từ trang gốc
&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>Code ở trang B</p>
<pre><code class="html">
&lt;body&gt;
    &lt;h1&gt;B页面&lt;/h1&gt;
    &lt;script&gt;
        window.onload = function() {
            window.addEventListener("message", function(e) {
                //Kiểm tra xem tin nhắn có phải đến trang gốc hay không để đảm bảo tính bảo mật
                if(e.source != window.parent) return;
                alert(e.data);
            });
        };
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>Kết quả như sau:</p>
<img src="public/img/giai-phap-cho-cross-domain-o-frontend/0.png" alt="">
<p><b>postMessage</b> nhận hai tham số đó là dữ liệu gửi đi và nguồn của iframe cần gửi (như ở đoạn code phía trên là <i>http://localhost:4003</i>). Trong trường hợp bạn muốn gửi cho tất cả các iframe bất kể nguồn nào bạn có đặt giá trị là "*". Về phần iframe muốn nhận được thông tin thì có thể sử dụng <i>window.addEventListener ("message", function () {})</i>.</p>
<h4>Những trường hợp không bị giới hạn bởi Same Origin Policy</h4>
<ul>
    <li>Thẻ <b>script</b> được phép nhúng các đoạn script từ cross-domain. JSONP được xem như một công nghệ dùng để khai thác "lỗ hổng" này.</li>
    <li>Các thẻ <b>img</b>, <b>link</b> và <b>@font-face</b> không bị ảnh hưởng bởi cross-domain</li>
    <li>Phần tài nguyên trong các thẻ <b>video</b> và <b>audio</b> cũng không bị giới hạn.</li>
    <li>Bất cứ tài nguyên nào cũng iframe (Các iframe không giao tiếp được với nhau).</li>
    <li>Plugins dành cho &lt;object&gt;, &lt;embed&gt;, và &lt;applet&gt;</li>
    <li>WebSocket cũng không chịu sự giới hạn của Same Origin Policy</li>
</ul>
<h4>Giải pháp chung cho các developer</h4>
<div class="blog-break-line"></div>
<h4>CORS - Chia sẽ tài nguyên của cross-domain</h4>
<p>Lưu ý: Hai hướng phân tích sau đây về việc chia sẽ tài nguyên với cross-domain được trích xuất trong bài viết <a href="">Chia sẽ cross-domain (跨域资源共享)</a> của <b>阮一峰 (Nguyễn Nhất Phong)</b></p>
<h4>Chia sẽ tài nguyên cross-domain là cái gì?</h4>
<p>CORS là một tiêu chuẩn của <b>W3C</b>, tên gọi đầy đủ là Cross-origin resource sharing</p>
<p>CORS cho phép trình duyệt đưa ra các XMLHttpRequest tới các cross-origin server. Đồng thời request đó có thể vượt qua các giới hạn của AJAX khi chỉ có thể gửi request đến những nơi có cùng một nguồn.</p>
<p>Việc triển khai CORS chủ yếu dựa vào những cài đặt ở phía server. <!-- còn 1 đoạn -->. Phần frontend thì gần như không thay đổi mấy so với việc sử dụng AJAX bình thường. Chỉ là chúng ta cần cập nhật một số cài đặt liên quan tới AJAX mà tôi sẽ nói trong phần tiếp theo.</p>
<h4>Hai loại request của CORS</h4>
<p>Để có thể chia sẽ được tài nguyên từ cross-domain, chúng ta cần xem xét hai loại request dưới đây.</p>
<p>Trình duyệt chia CORS ra làm hai loại request. Loại đầu tiên là loại đơn giản còn loại còn lại thì... chắc chắn là loại không đơn giản rồi. (Người dịch: vãi ông viết bài -_-)</p>
<p>Chỉ cần đạt được hai yêu cầu sau thì chúng ta có thể đánh giá đó là single request.</p>
<p>Phương thức yêu cầu là một trong ba phương thức sau đây:</p>
<ul>
    <li>HEAD</li>
    <li>GET</li>
    <li>POST</li>
</ul>
<p>Thông tin của HTTP Header không vượt quá các trường sau đây:</p>
<ul>
    <li>Accept</li>
    <li>Accept-Language</li>
    <li>Content-Language</li>
    <li>Last-Event-ID</li>
    <li>Content-Type: Giới hạn trong ba giá trị sau đây <b>application/x-www-form-urlencoded</b>, <b>multipart/formdata</b> và <b>text/plain</b></li>
</ul>
<p>Còn nếu request không thõa mãn bất kỳ một điều kiện nào trong những điều kiện kể trên thì đó là preflight request</p>
<p>Trình duyệt cũng có cách xử lý khác nhau đối với các loại request.</p>
<h4>Simple request</h4>
<p>Đối với simple request thì trình duyệt sẽ gửi CORS request trực tiếp. Cụ thể, sẽ thêm trường <b>Origin</b> vào bên trong phần HTTP header như sau:</p>
<pre><code class="http">
GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
<p>Trường <b>Origin</b> ở phía trên được dùng để chỉ định nguồn (protocol + tên miền + cổng) mà request đến. Dựa trên giá trị này, server sẽ quyết định là có thông qua request hay không.</p>
<p>Nếu tên nguồn được khai báo trong <b>Origin</b> không nằm trong phạm vi những nguồn được cho phép của server thì server sẽ trả về một HTTP response bình thường. Khi nhận được HTTP response từ server và không hề chứ trường <b>Access-Control-Allow-Origin</b> (như bên dưới) thì có nghĩa đã có đó không đúng xảy ra. Và lỗi đó sẽ được tìm thấy ở function onerror của XMLHttpRequest. Lưu ý một tí là bạn không nên dùng status code để phát hiện lỗi này vì đôi lúc status code trả về sẽ là 200 (dù có phát sinh lỗi).</p>
<p>Còn trong trường hợp tên nguồn nằm trong <b>Origin</b> nằm trong phạm vi những nguồn được cho phép của server thì phần header được phản hồi lại sẽ có dạng tương tự như sau:</p>
<pre><code class="http">
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
</code></pre>
<p>Trong HTTP response header trên thì có ba trường có liên quan đến CORS được bắt đầu bằng <i>Access-Control-</i></p>
<p><b>Access-Control-Allow-Origin</b></p>
<p>Đây là một trường bắt buộc, giá trị của trường này là những thứ mà Origin yêu cầu hoặc là "*" (cho biết rằng mọi tên miền đều được chấp nhận).</p>
<p><b>Access-Control-Allow-Credentials</b></p>
<p>Đây là một trường không hề bắt buộc. Kiểu giá trị của trường này là Boolean quy định rằng Cookie có cần được gửi hay không. Mặc định thì CORS không bật trường này lên. Còn nếu có giá trị là true thì có nghĩa server quy định rằng bạn phải gửi cookie lên kèm trong request. Giá trị của trường này luôn là true. Nếu không dùng thì bạn chỉ cần xóa nó đi (thay vì set lại là false).</p>
<p>Một điều lưu tâm là đển CORS có thể hỗ trợ Cookie thì bạn không chỉ phải thiết lập trong HTTP response từ server. Mà còn phải dùng <b>withCredentials</b> dành cho AJAX như sau (cấu hình dành cho jQuery sẽ được đề cập sau):</p>
<pre><code class="javascript">
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
</code></pre>
<p>Đôi khi một số trình duyệt vẫn gửi Cookie dù bạn đã bỏ qua thuộc tính <b>withCredentials</b>. Vì vậy, trong trường hợp đó, để tắt nó thì chúng ta có thể thao tác đơn giản như bên dưới:</p>
<pre><code class="javascript">
xhr.withCredentials = false;
</code></pre>
<p><b>Chú ý rằng nếu bạn muốn gửi Cookie lên thì Access-Control-Allow-Origin không được phép set là * mà phải đặt một tên miền cụ thế. Nếu bạn đang thực hiện debug ở local thì bạn có thể xem xét để chuyển đổi cài đặt sang null.</b></p>
<h4>Access-Control-Expose-Headers</h4>
<p>Giống như Access-Control-Allow-Credentials, đây cũng không phải là một trường bắt buộc. Trong CORS, phương thức <b>getResponseHeader()</b> của <b>XMLHttpRequest</b> chi có thể lấy được sáu trường là: <i>Cache-Control</i>, <i>Content-Language</i>, <i>Content-Type</i>, <i>Expires</i>, <i>Last-Modified</i> và <i>Pragma</i>. Nếu bạn muốn lấy thêm những trường khác, bạn bắt buộc phải chỉ định chúng trong <b>Access-Control-Expose-Headers</b>. Kết hợp với ví dụ ở trên, bạn có thể dùng <b>getResponseHeader('FooBar')</b> để lấy dữ liệu của <b>FooBar</b></p>
<h4>Preflight request</h4>
<p>Preflight request là loại request đặc biệt dành cho server. Ví dụ như sẽ dụng phương thức như <b>PUT</b> hoặc <b>DELETE</b> hay trường <b>Content-Type</b> có giá trị là <b>application/json</b>.</p>
<p>Một CORS request đối với preflight request sẽ được bổ sung thêm một HTTP request, được gọi là "pre flight (tiền trạm)" request sẽ được gửi đi. Sau đó, mới đến request chính thức.</p>
<p>Ở request đầu tiên từ trình duyệt, server sẽ kiểm tra xem tên miền hiện tại có nằm trong danh sách được phép hay không. XMLHttpRequest sẽ chỉ gửi đi yêu cầu chính thức nếu nhận được một response tích cực từ server. Nếu response trả về không được như mong đợi thì server cũng sẽ trả lỗi về.</p>
<p>Đây là đoạn code JavaScript</p>
<pre><code class="javascript">
var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
</code></pre>
<p>Rõ ràng chúng ta có thể thấy rằng đây là một preflight request. Phương thức được gửi đi là <b>PUT</b>, đồng thời kèm theo một trường được custom trong HTTP header.</p>
<p>Do vậy, nên trình duyệt sẽ đánh giá đây là một preflight request, đồng thời sẽ tự động gửi ra một request "tiền trạm" đến server. Dưới đây là thông tin HTTP header request của preflight request này.</p>
<pre><code class="http">
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
<p>Phương thức sử dụng trong request tiền trạm này là <b>OPTIONS</b>, để cho phía server biết được request này là request thăm dò. Trong thông tin của Header gồm có trường <b>Origin</b> cho biết nguồn của yêu cầu đến từ đâu.</p>
<p>Ngoài <b>Origin</b> ra thì phần header của request "tiền tạm" cũng có hai trường cần để ý.</p>
<p><b>Access-Control-Request-Method</b></p>
<p>Trường này là bắt buộc, nhằm để khai báo phương thức của CORS request. Như ở trên chúng ta có thể thấy là <b>PUT</b></p>
<p><b>Access-Control-Request-Headers</b></p>
<p>Trường này là một chuỗi được phân cách bằng dấu phẩy chỉ định những thông tin mà trong header của CORS request sẽ gửi thêm (ngoài những thông tin mặc định). Như đã thất ở trên đó là <b>X-Custom-Header</b>.</p>
<p><b>Access-Control-Request-Headers</b></p>
<p>Sau khi nhận được request "tiền trạm" thì server sẽ kiểm tra các trường <b>Origin</b>, <b>Access-Control-Request-Method</b> và <b>Access-Control-Request-Headers</b>. Nếu hợp lệ, server sẽ phản hồi lại cho trình duyệt như sau:</p>
<pre><code class="http">
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
</code></pre>
<p>Nếu server từ chối request tiền trạm này, server sẽ trả về một HTTP response bình thường và không có trường nào liên quan đến CORS. Đồng thời ngay lúc này, trình duyệt sẽ giả định rằng server không đồng ý với với yêu cầu tiền trạm. Vì thế nên XMLHttpRequest sẽ kích hoạt lỗi trong onerror dưới dạng như bên dưới:</p>
<pre><code class="sql">
XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
</code></pre>
<p>Ngoài ra còn một số trường khác có liên quan đến CORS mà server phản hồi:</p>
<pre><code class="http">
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
</code></pre>
<p>So sánh với nhưng gì mà CORS trả về cho simple request thì ở đây chúng ta có thể thấy được ba trường khác biệt như sau:</p>
<p><b>Access-Control-Allow-Methods</b></p>
<p>Đây là một trường bắt buộc, giá trị của nó là một chuỗi được ngăn cách bằng dấu phẩy. Liệt tất cả những phương thức của cross-domain được hỗ trợ bởi server. Lưu ý rằng tất cả các phương thức mà server hổ trợ sẽ được trả về. Tôi lặp lại điều này để tránh việc nhầm lẫn với <b>Access-Control-Allow-Methods</b> của request tiền trạm mà tôi đã đề cập ở phía trên.</p>
<p><b>Access-Control-Allow-Headers</b></p>
<p>Nếu trình duyệt gửi request có chứa <b>Access-Control-Allow-Headers</b>, thì trường <b>Access-Control-Allow-Headers</b> sẽ là bắt buộc. Giá trị của trường này là mỗi chuỗi được phân cách bởi dấu phẩy, bao gồm các trường custom được server hỗ trợ. Giống như ở trên, những giá trị của <b>Access-Control-Allow-Headers</b> ở đây cũng không bị giới hạn bởi những giá của request tiền trạm ở trên.</p>
<p><b>Access-Control-Max-Age</b></p>
<p>Đây là một trường không bắt buộc, dùng để chỉ định thời hạn của request tiền trạm này và đơn vị sử dụng là giây. Trong đoạn kết quả ở trên chúng ta có thể thấy giá trị là 1728000 giây (20 ngày). Nghĩa là phản hồi này sẽ được cache lại trong 20 ngày. Trong thời gian này, sẽ không cần phải gửi yêu cầu tiền trạm nửa.</p>
<p>Do đó, mỗi khi mà trình duyệt vượt qua được "trạm soát vé" ở phía server, mỗi request CORS tiếp theo sẽ được xem như một simple request, vẫn có trường <b>Origin</b>. Phản hồi của server cũng sẽ có <b>Access-Control-Allow-Origin</b>. Nếu bạn có sử dụng Cookie thì <b>Access-Control-Allow-Credentials</b> cũng sẽ được thiết lập là <i>true</i> (như ở trên đã đền cập).</p>
<h4>Làm thể nào để có thể dùng CORS cho cross-domain khi sử dụng Node?</h4>
<p>Câu hỏi của phần này là cách thức để thực hiện chia sẽ tài nguyên cho cross-domain với <b>Express</b>.</p>
<p>Thực tế, cách thức khá đơn giản. Bạn chỉ cần phải thiết lập các trường đã được đề cập ở trên. Đồng thời cần để ý các vấn đề như hai loại yêu cầu, có sử dụng Cookie hay không. Bạn có thể tham khảo đoạn code dưới đây.</p>
<pre><code class="javascript">
app.all("*", function(req, res, next) {
    res.header("Access-Control-Allow-Origin", /* url | * | null */);
    res.header("Access-Control-Allow-Headers", "Authorization, X-Requested-With");
    res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS"); /* Những phương thức mà server sẽ hỗ trợ */
    res.header("Access-Control-Allow-Credentials", "true"); /* Bật lên khi bạn sử dụng Cookie */
    res.header("Access-Control-Max-Age", 300000); /* Thời gian hiệu lực của yêu cầu tiền trạm */
    if (req.method === "OPTIONS") return res.send(200); /* Cho phép các request với phương thức OPTIONS phản hồi lại nhanh */
    else next();
});
</code></pre>
<p>Nhìn vào đoạn code trên, có một số phần tôi cần các bạn lưu ý:</p>
<ul>
    <li>Nếu bạn cần debug ở local, bạn cần đặt giá trị <b>Access-Control-Allow-Origin</b> thành <i>null</i> để có thể sử dụng Cookie. Vì mặc dù bạn vẫn có thể gửi các request nếu đặt giá trị là <i>*</i>, nhưng lúc này sẽ không thể nào dùng được Cookie.</li>
    <li><b>Access-Control-Allow-Headers</b> là không bắt buộc phải thiết lập, cho nên phải chỉ cần phải thiết lập nó khi nào những request được gửi lên có <b>Access-Control-Allow-Headers</b></li>
    <li>Hãy nhớ config <b>Access-Control-Allow-Methods</b> khi bạn muốn dùng Cookie.</li>
    <li>Request tiền trạm có thể được được thiết lập cache. Điều đó sẽ đảm bảo cho bạn rằng không xảy ra hiện tượng nhiều request tiền trạm được gửi đi cùng một lúc.</li>
    <li>Cần xác định request hiện tại có phải là request tiền trạm hay không. Nếu phải thì return ngay. (<b>Người dịch:</b> <i>Các bạn có thể tham khảo đoạn if phía trên. Làm thế nhầm đảm bảo không xảy ra các thao tác thừa thãi. Vì đôi khi các thao tác thừa đó có thể gây ra các bug tiềm ẩn.</i>).</li>
</ul>
<p>Như đã từng nói ở trên. Trong trường hợp bạn dùng jQuery để gửi AJAX thì các bạn có thể tham khảo đoạn code dưới đây.</p>
<pre><code class="javascript">
$.ajaxSetup({ xhrFields: { withCredentials: true }, crossDomain: true });
</code></pre>
<p>
    Bật <b>withCredentials</b> nếu bạn muốn gửi đi Cookie. Mặc định thì jQuery sẽ không gửi. <br />
    Bật <b>crossDomain</b> để AJAX có thể sử dụng cross-domain.
</p>
<p>Như vậy, trên đây tôi đã giới thiệu sơ về CORS dành cho cross-domain. Sau đây, chung ta sẽ đến phần tiếp theo của bài viết.</p>
<h4>Triển khai cross-domain với công nghệ JSONP</h4>
<div class="blog-break-line"></div>
<h4>JSONP</h4>
<p>Về <b>JSONP</b>, như tôi đã đề cập trước đó. Thực tế, việc dùng nó để giải quyết vấn đề Same Origin Policy được xem là lợi dụng một "lổ hỏng". Nhưng không sao, tất cả cũng là để hoàn thành đại cuộc "khúc tuyến cứu quốc" <a title="Khúc tuyến cứu quốc" class="note-item" id="khuc-tuyen-cuu-quoc-in-page" href="#khuc-tuyen-cuu-quoc"></a>.</p>
<p>Như đã biết, thẻ <b>script</b> không bị giới hạn bởi <b>Same Origin Policy</b>. Và phương pháp này thì tận dụng điều đó bằng các thêm tự động các thẻ <b>script</b> vào trang. Đồng thời dùng các xử lý có sẵn (từ server) để lấy được dữ liệu.</p>
<p>Có một điều tôi muốn nhấn mạnh, đó là phương pháp này hoàn toàn khác với CORS. Đây cũng không phải là một đặc điểm kỹ thuật. Cái thứ mà chúng ta gọi là <b>JSONP</b> thật ra là một cách mới trong việc ứng dụng JSON. Hay nói đơn giản, nó chỉ là một đoạn JSON được thêm vào trang thông qua một function.</p>
<p>Hai thành phần của <b>JSONP</b> đó chính là dữ liệu và callback function. Trong đó, callback function sẽ được gọi khi trang hiện tại có phản hồi. Dữ liệu JSON sẽ được truyền vào bên trong callback function đó. Dưới đây, tôi sẽ mô phỏng quá trình đó của <b>JSONP</b></p>
<p>Nguyễn tắc của <b>JSONP</b> có thể được tham khảo ở <a target="_blank" href="https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html">đây (tiếng Trung)</a>.</p>
<p>Mô phỏng ngắn gọn quá tình giao tiếp của JSONP</p>
<pre><code class="javascript">
function handleResponse(response) {
    console.log(response.data);
}
var script = document.createElement("script");
script.src = "http://example.com/jsonp/getSomething?uid=123&callback=hadleResponse"
document.body.insertBefore(script, document.body.firstChild);
/*handleResponse({"data": "hey"})*/
</code></pre>
<p>Quy trình trong đoạn code trên được diễn ra như sau:</p>
<ul>
    <li>Khi chúng ta request một thẻ <b>script</b> mới, một dữ liệu JSON tương ứng sẽ được tạo ra (từ nguồn trong src mà chúng ta đã chỉ định). Ví dụ như ở trên, chúng ta có thể thấy <b>handleResponse</b> được thêm vào link với tên là callback. 
    <!--Sau khi có dữ liệu, dữ liệu sẽ được tương tác như sau: <i>handleResponse({"data": "hey"})</i>-->
    .</li>
    <li>Sau đó, dữ liệu JSON được trả về (chúng ta có thể xem nó như một file js). Thứ mà sẽ là tham số được gọn trong function.</li>
    <li>Do chúng ta đã khai báo function ở phía trên. Nên ngay khi dữ liệu được tải về (bên trong thẻ script). Function đó sẽ được gọi trực tiếp với dữ liệu mà chúng ta vừa thu được.</li>
    <li>Tại thời điểm này, việc giao tiếp với cross-domain xem như đã được hoàn tất.</li>
</ul>
<p>Ngoài ra, để có thể thực hiện <b>JSONP</b> thì chúng ta không thể thiếu đi sự cài đặt tương ứng ở phía server.</p>
<p>Đương nhiên, <b>JSONP</b> cũng có những hạn chế nhất định:</p>
<ul>
    <li>Chỉ có thể dùng phương thức GET</li>
    <li>Có kha khá khả năng rủi ro về bảo mật trong quá trình gửi yêu cầu.</li>
    <li>Sẽ không dễ để xác định một request JSONP bị thất bại.</li>
</ul>
<h4>Một cách triển khai JSONP đơn giản</h4>
<p>Dưới đây là một thư viện dùng để triển khai <b>JSONP</b>. Hãy thử phân tích source code của nó. Đồng thời các bạn có thể tham khảo nó ở <a target="_blank" href="https://github.com/webmodules/jsonp">Github</a>.</p>
<pre><code class="javascript">
/**
 * Module dependencies
 */

var debug = require('debug')('jsonp');
// Gọi thư viện ra

/**
 * Module exports.
 */

module.exports = jsonp;
// exports jsonp

/**
 * Callback index.
 */

var count = 0;
// Biến này được xem như một index, dùng để generate ra id (không trùng lặp)。

/**
 * Noop function.
 */

function noop(){}
//đây là một function trống. Thuộc tính window[id] sẽ được gán vào function này sau.

/**
 * JSONP handler
 *
 * Options:
 *  - param {String} qs parameter (`callback`)
 *  - prefix {String} qs parameter (`__jp`)
 *  - name {String} qs parameter (`prefix` + incr)
 *  - timeout {Number} how long after a timeout error is emitted (`60000`)
 *
 * @param {String} url
 * @param {Object|Function} optional options / callback // callback function ở đây là function được gọi sau khi có dữ liệu, không phải là callback function gửi lên server
 * @param {Function} optional callback
 */


function jsonp(url, opts, fn){
  if ('function' == typeof opts) {
    fn = opts;
    opts = {};
  }
  if (!opts) opts = {};

  var prefix = opts.prefix || '__jp';

  // use the callback name that was passed if one was provided.
  // otherwise generate a unique name by incrementing our counter.
  var id = opts.name || (prefix + (count++));

  var param = opts.param || 'callback';
  var timeout = null != opts.timeout ? opts.timeout : 60000;
  var enc = encodeURIComponent;
  var target = document.getElementsByTagName('script')[0] || document.head;
  var script;
  var timer;

  //Server sẽ không trả dữ liệu về nếu hết thời gian chờ.
  if (timeout) {
    timer = setTimeout(function(){
      cleanup();
      if (fn) fn(new Error('Timeout'));
    }, timeout);
  }
  // Dọn dẹn, trở về trạng thái ban đầu (Người dịch: sử dụng phương thức noop như mình đã đề cập phía trên.)
  function cleanup(){
    if (script.parentNode) script.parentNode.removeChild(script);
    window[id] = noop;
    if (timer) clearTimeout(timer);
  }
  // Hủy hoạt động
  function cancel(){
    if (window[id]) {
      cleanup();
    }
  }
    
  // Khai báo function mà sau khi url được tải vào trong thẻ script sẽ được gọi
  window[id] = function(data){
    debug('jsonp got', data);
    cleanup();
    if (fn) fn(null, data);// tham số đầu tiên trong node là err, nếu không thể truyền vào ở đây thì null sẽ được truyền vào.
  };

  // add qs component
  url += (~url.indexOf('?') ? '&' : '?') + param + '=' + enc(id);
  url = url.replace('?&', '?');

  debug('jsonp req "%s"', url);

  // create script
  script = document.createElement('script');
  script.src = url;
  target.parentNode.insertBefore(script, target);
  // sau khi được khởi tạo, function được khai báo sẽ được gọi trực tiếp với những dữ liệu được lấy từ thẻ script

  return cancel;
  // quay lại trạng thái ban đầu.
}
</code></pre>
<h4>Đóng gói thư viện JSONP</h4>
<p>Sử dụng thư viện trên cho quá trình đóng gói, dưới đây sẽ là function _jsonp của chúng ta:</p>
<pre><code class="javascript">
/* Đây là một function _jsonp được định nghĩa bởi chính tôi */
/**
 * @param {String} url 
 * @param {Object} data 
 * @param {Object} option 
 * @returns 
 */
function _jsonp(url, data, option) {
  url += (url.indexOf('?') < 0 ? '?' : '&') + param(data);

  return new Promise((resolve, reject) => {
    jsonp(url, option, (err, data) => {
      if (!err) {
        resolve(data);
      } else {
        reject(err);
      }
    });
  });
  /* jsonp sẽ được trả về dưới dạng Promise. Nếu mọi chuyện ổn thì dữ liệu sẽ được đưa vào resolve */
}
// Tiếp theo là một function để xử lý các tham số
function param(data) {
  let url = '';
  for (var k in data) {
    let value = data[k] !== undefined ? data[k] : '';
    url += `&${k}=${encodeURIComponent(value)}`;
  }
  return url ? url.substring(1) : '';/*  những substring dưới đây sẽ đảm bảo không có thêm & */
}
</code></pre>
<h4>Sử dụng JSONP với jQuery</h4>
<p>Ngoài ra, chúng ta có thể sử dụng JSONP với jQuery. Đây là một đoạn code mẫu ngắn gọn về cách dùng.</p>
<pre><code class="javascript">
$.ajax({  
    type: "get",  
    url: "http://example.com",  
    dataType: "jsonp",  
    jsonp: "callback",
    jsonpCallback: "responseCallback",
    success: function (data) {  
        console.log(data);
    },  
    error: function (data) {  
        console.log(data);
    }  
});
</code></pre>
<p>Trong AJAX, thiết lập dataType là jsonp. Còn đối với jsonp thì có mặc định là callback. Còn với jsonpCallback thì giá trị được jQuery tạo mặc định. Nếu bạn muốn tự định nghĩa function lại, các bạn có thể thiết lập lại jsonpCallback như trong đoạn code trên. Trong đoạn code trên, đoạn url cuối cùng được gửi sẽ là <i>http://example.com?callback=responseCallback</i></p>
<h4>Sử dụng proxy server để chuyển tiếp các request</h4>
<p>Bởi vì Same Origin Policy chỉ tồn tại trong trình duyệt. Nên trong giao tiếp giữa server và server, thì không bị giới hạn bởi sự tương đồng.<br />
Do đó, việc sử dụng proxy server như là một giải pháp trong việc giải quyết các vấn đề của cross-domain, cũng là một cách phổ biển trong quá trình phát triển phần mềm hàng ngày của chúng tôi.</p>
<p>Cách triển khai cũng rất đơn giản, chỉ cần <b>Node</b> và <b>Express</b>.</p>
<p>Bạn cũng nên lưu ý rằng thường thì server sẽ có cơ chế xác minh riêng. Ví dụ: các bài viết của WeChat sẽ không thể tải được trong iframe, bởi vì server được xác minh bởi referer. Ngoài ra, đối với một số server còn đòi hỏi cung cấp xác minh như phải gửi một chuỗi uid... Do đó, khi dùng proxy server, chúng ta nên tập trung vào các tham số của request để có thể mô phỏng chính xác nhất request cần mô phần, góp phần đảm bảo quá trình chuyển tiếp chính xác nhất.</p>
<p>Điểm qua một các tổng quan về cách mà proxy server thực hiện chuyển tiếp request:</p>
<ul>
    <li>Phân tích các tham số cần thiết của request url.</li>
    <li>Proxy server sẽ gọi api. Chức năng thực tế của giai đoạn này request đến server thật.</li>
    <li>Sau đó, proxy server mà bạn đã tạo sẽ giúp bạn chuyển tiếp request mà bạn muốn đến server thật sự với các tham số cần thiết.</li>
</ul>
<p>Cuối cùng, tôi sẽ thực hiện một ví dụ về sử dụng proxy server nhằm vượt qua phần bảo mật của WeChat.</p>
<h4>Vậy làm cách nào để vượt qua cơ chế chống trộm của WeChat?</h4>
<p>Giả sử chúng ta có một trang website, thẻ <b>img</b> sẽ tham chiếu đến một hình ảnh của WeChat. Hãy xem điều gì xảy ra sau đây.</p>
<img src="public/img/giai-phap-cho-cross-domain-o-frontend/1.png" alt="">
<p>Đây là cái tôi gọi là cơ chế chống trộm.</p>
<p>Bây giờ, hãy thử tạo một proxy server. Code của nó như sau:</p>
<pre><code class="javascript">
var express = require("express");
var superagent = require("superagent");
var app = express();

app.use("/static", express.static("public"));

app.get("/getwxImg", (req, res) => {
    // xử lý không bị mất url vì có hai dấu chấm hỏi
    var url = req.url.substring(req.url.indexOf("param=") + 6);
    res.writeHead(200, {
        'Content-Type': 'image/*'
    });
    superagent.get(url)
        .set('Referer', '')
        .set("User-Agent",
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'
        )
        .end(function (err, result) {
            if (err) {
                return false;
            }
            res.end(result.body);
            return;
        });
});

app.listen(4001, (err) => {
    if (err) {
        console.log(err);
    } else {
        console.log("server run!");
    }
});
</code></pre> 
<p>Bằng cách này, chúng ta có thể thay thế url đến server thực, bằng cách gọi đến proxy server và sử dụng url đó như là một tham số.</p>
<pre><code class="html">
&lt;!-- sử dụng proxy server --&gt;
&lt;img src="http://localhost:4001/getwxImg?param=http://mmbiz.qpic.cn/mmbiz/CoJreiaicGKekEsuheJJ7Xh53AFe1BJKibyaQzsFiaxfHHdYibsHzfnicbcsj6yBmtYoJXxia9tFufsPxyn48UxiaccaAA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&tp=webp"&gt;
&lt;!-- dùng cách thông thường --&gt;
&lt;img src="http://mmbiz.qpic.cn/mmbiz/CoJreiaicGKekEsuheJJ7Xh53AFe1BJKibyaQzsFiaxfHHdYibsHzfnicbcsj6yBmtYoJXxia9tFufsPxyn48UxiaccaAA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&tp=webp"&gt;
</code></pre> 
<p>Kết quả như sau:</p>
<img src="public/img/giai-phap-cho-cross-domain-o-frontend/2.png" alt="">
<p>Đúng là một kết quả hiển nhiên đúng không nào? Đây chính là một ví dụ về proxy server. Các bạn có thể xem toàn bộ code ở <a href="https://github.com/stevennzhou/weixinPictureReverseUrl" target="_blank">đây</a></p>
<p>Một số nguồn tham khảo:</p>
<p>Same Origin Policy: <a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p>
<p>Cookie và Session: <a href="http://www.cnblogs.com/linguoguo/p/5106618.html">http://www.cnblogs.com/linguoguo/p/5106618.html</a></p>
<p>CORS: <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<div class="blog-break-line"></div>
<h4>Kết (người dịch)</h4>
<p>Trên đây lại là một bài dịch mà mình đã tìm thấy trên <b>segmentfault</b>. Như các bạn cũng có thể thấy, đây là một bài viết hết sức chi tiết về vấn đề hạn chế tài nguyên giữa các tên miền khác nhau. Nhờ bài viết này mà mình cũng sáng ra khá nhiều thứ mà đó giờ mình không biết. Hy vọng bài viết này có ích cho các bạn đang làm việc với cross-domain. Cuối cùng, một lần nửa xin cám ơn tác giả về bài viết này.</p>
<div class="blog-break-line"></div>
<h4><i>Chú thích</i></h4>
<ul class="noted">
    <li id="khuc-tuyen-cuu-quoc"><b>Khúc tuyến cứu quốc:</b>: Nguyên gốc hán tự là <i>曲线救国</i>. Đây là một từ xuất hiện trong thời kháng Nhật. 
    Chúng ta cũng có thể đọc là "gián tiếp cứu nước". Tronng giai đoạn này, người Trung Quốc làm đủ cách để làm chậm quá trình xâm chiếm của Nhật từ đánh du kích, biểu tình... Hy sinh việc nhỏ vì việc lớn. Câu này dùng trong bài với hàm ý là vì việc lớn mà bỏ qua tiểu tiết (vì muốn giải quyết vấn đề cross-domain mà dùng JSONP. Một cách mà tác giả xem đó là một "lỗ hỏng") <a href="#khuc-tuyen-cuu-quoc-in-page">[<span class="fa fa-angle-double-up"></span>]</a></li>
</ul>

<div class="blog-detail-comments">
    <!-- <div id="show-comment-box">
        Comment
    </div> -->
    <div id="post-comment">
        <div id="disqus_thread"></div>
        <script>
        /**
        *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
        *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
        /*
        var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
        */
        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://https-tasynguyen3894-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
</div>
<div class="blog-break-line"></div>
</div>
</div>
                </div>
                <footer>
                    <div>Created with <a href="https://github.com/tasynguyen3894/1989stack">1989Stack</a>
                        | <a href="tags.html"><span class="fa fa-tag"></span></a>
                        <a href="https://twitter.com/tasyit"><span class="fa fa-twitter"></span></a>
                        <a href="https://github.com/tasynguyen3894"><span class="fa fa-github"></span></a>
                    </div>
                    <div><a href="/">sangnguyen.dev</a> - <a href="versions.html">Verison 1.2.0</a> &copy 2018</div>
                </footer>
            </div>
        </div>
        <script src="/public/js/main.js"></script>
        <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
            </body>
</html>